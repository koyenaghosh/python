# -*- coding: utf-8 -*-
"""exception handling.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1BP5pDWdH2Me7vRbkCF55F_koxYHPHq01

How to handle exceptions?
"""

#create a file

with open('sample.txt','w') as f:
  f.write('hello world!')

#try except

try:

  with open('sample2.txt','r') as f:
    print(f.read())

except:
  print('oops! file not found')

# catching specific exception
try:
  f=open('sample1.txt','r')
  print(f.read())
  print(m)
except Exception as e:
  print(e.with_traceback)
  print(e)
# write different except blocks for different errors to handle every exception separately

try:
  m=5
  f=open('sample.txt','r')
  print(f.read())
  print(m)
  print(m/2)
  print(m.upper())
except FileNotFoundError:
  print('file not found')
except NameError:
  print('variable not found')
except ZeroDivisionError:
  print('cannot divide by zero')
except Exception as e:#generalised exception handling. should always be written at the last.
  print(e)

#else block
try:
  f=open('sample1.txt','r')
except FileNotFoundError:
  print('file not found')
except Exception:
  print('some other error')
else:
  print(f.read())

# we use else when 'try' block has no error and we write the code which is to be run surely, within the else block

#finally
try:
  f=open('sample1.txt','r')
except FileNotFoundError:
  print('file not found')
except Exception:
  print('some other error')
else:
  print(f.read())
finally:
  print('This will get printed surely:)') #inspite of any intermediate error, this part of the code runs surely irrespective of anything else.

"""Raise exception"""

raise NameError('hehe')

raise IndentationError('omkeeeee')

class Bank:
  def __init__(self,balance):
    self.balance=balance
  def withdraw(self,amount):
    if amount<0:
      raise Exception('amount cannot be -ve')
    if self.balance<amount:
      raise Exception('insufficient balance !!!!')
    self.balance=self.balance-amount

user=Bank(int(input('enter current balance: ')))
try:
  user.withdraw(int(input('enter amount to be withdrawn: ')))
except Exception as e:
  print(e)
else:
  print(user.balance)

"""Create customised Exception Class"""

class MyException(Exception):  #your customised exception class must always be a child class of "Exception"
  def __init__(self,message):
    self.message=message
    print(message)

class Bank:
  def __init__(self,balance):
    self.balance=balance
  def withdraw(self,amount):
    if amount<0:
      raise MyException('amount cannot be -ve')
    if self.balance<amount:
      raise MyException('insufficient balance !!!!')
    self.balance=self.balance-amount

user=Bank(int(input('enter current balance: ')))
try:
  user.withdraw(int(input('enter amount to be withdrawn: ')))
except MyException as e:
  pass
else:
  print(user.balance)

